{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:/webpack/bootstrap cef0d9a3d38c6f8846dc?7492","webpack:///src/graph.es6.js?8eb6"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","id","loaded","modules","call","m","c","p","_vertices","Symbol","_edges","_reverseEdges","_sources","_sinks","_edgeCount","_listeners","_trigger","_verticesFrom","_verticesTo","_verticesWithPathTo","_verticesWithPathFrom","_paths","_expectVertices","_expectVerticesAbsent","_expectEdges","_expectEdgesAbsent","_expectNoConnectedEdges","Graph","Map","Set","parts","Array","_len","_key","arguments","_iterator","iterator","_step","_iteratorNormalCompletion","next","done","key","_step$value","value","isArray","from","_key2","to","createEdge","addVertex","on","event","handler","has","set","get","add","off","_value","_iterator2","_step2","_iteratorNormalCompletion2","addNewVertex","setVertex","ensureVertex","hasVertex","removeExistingVertex","destroyExistingVertex","_iterator3","verticesFrom","_step3","_iteratorNormalCompletion3","_step3$value","removeEdge","_iterator4","verticesTo","_step4","_iteratorNormalCompletion4","_step4$value","removeVertex","destroyVertex","vertexCount","size","vertexValue","addNewEdge","createNewEdge","setEdge","spanEdge","hasEdge","addEdge","ensureEdge","removeExistingEdge","inDegree","outDegree","edgeCount","edgeValue","undefined","vertices","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","_step5$value","edges","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","keys","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_iterator8","_step8","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_iterator9","_step9","verticesWithPathFrom","_step10","verticesWithPathTo","_step11","sources","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_iterator12","_step12","sinks","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_iterator13","_step13","vertices_topologically","visited","handled","_this","visit","_iteratorNormalCompletion15","_didIteratorError15","_iteratorError15","_iterator15","_step15","_step15$value","a","i","cycle","_iteratorNormalCompletion14","_didIteratorError14","_iteratorError14","_iterator14","_step14","_step14$value","b","push","indexOf","length","slice","reverse","CycleError","pop","map","regeneratorRuntime","mark","clearEdges","_iterator16","_step16","_iteratorNormalCompletion16","_step16$value","clear","_iterator17","_step17","_iteratorNormalCompletion17","v","_step17$value","equals","other","eqV","x","y","eqE","_iterator18","_step18","_iteratorNormalCompletion18","_step18$value","_iterator19","_step19","_iteratorNormalCompletion19","_step19$value","apply","cycles","pointStack","markedStack","backtrack","_iteratorNormalCompletion20","_didIteratorError20","_iteratorError20","_iterator20","_step20","_step20$value","out","w","o","u","_arr$_i","found","result","hasCycle","paths","stack","pathsFromPrefix","current","_step21$value","path","hasPath","degree","mergeIn","mV","mE","v1","v2","_iterator22","_step22","_iteratorNormalCompletion22","_step22$value","_iterator23","_step23","_iteratorNormalCompletion23","_step23$value","clone","trV","trE","transitiveReduction","_iterator24","_step24","_iteratorNormalCompletion24","_step24$value","_iterator25","_step25","_iteratorNormalCompletion25","_step25$value","_iterator26","_step26","_iteratorNormalCompletion26","z","_step26$value","contractPaths","isNexus","nexuses","concat","_toConsumableArray","filter","_ref","_ref2","val","_this2","_ref3","_ref32","unhandledVertices","_ref4","_ref42","checkForBlCycle","_iterator27","_step27","_iteratorNormalCompletion27","_step27$value","_iterator28","_step28","_iteratorNormalCompletion28","_step28$value","_iterator29","_iteratorNormalCompletion29","_step29","startingKey","values","BranchlessCycleError","contractionsToAdd","startPath","start","backwards","fromTo","strt","nxt","verticesNext","verticesToRemove","edgesToRemove","_ref5","_iterator30","_step30","_iteratorNormalCompletion30","_iterator31","_step31","_iteratorNormalCompletion31","_iterator32","_step32","_iteratorNormalCompletion32","first","_iterator34","_step34","_iteratorNormalCompletion34","_step34$value","_iterator35","_step35","_iteratorNormalCompletion35","_step35$value","_iterator33","_step33","_iteratorNormalCompletion33","_step33$value","toVal","_iterator36","_step36","_iteratorNormalCompletion36","_step36$value","rememberedPath","toJSON","_iterator37","_step37","_iteratorNormalCompletion37","_step37$value","_iterator38","_step38","_iteratorNormalCompletion38","_step38$value","JSON","stringify","_len2","_key3","missingVertices","k","_this3","_bind","VertexNotExistsError","_len3","_key4","presentVertices","_this4","VertexExistsError","_len4","_key5","absentEdges","_this5","EdgeNotExistsError","_len5","_key6","presentEdges","_this6","EdgeExistsError","_iterator39","_step39","_iteratorNormalCompletion39","_step39$value","_iterator40","_step40","_iteratorNormalCompletion40","_step40$value","HasConnectedEdgesError","fromJSON","json","parse","_Error","_get","Object","getPrototypeOf","prototype","_len6","_key7","message","_ref6","_ref62","join","Error","_Error2","_len7","_key8","_Error3","_len8","_key9","_ref7","_ref72$0","_Error4","_len9","_key10","_ref8","_ref82","_Graph$EdgeExistsError","_len10","_key11","vertex","_ref9","_ref92$0","_Error5","_Graph$CycleError"],"mappings":"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","file":"dist/graph.min.js","sourceRoot":"","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Graph\"] = factory();\n\telse\n\t\troot[\"Graph\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cef0d9a3d38c6f8846dc","'use strict';\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Symbols for private members /////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n\nconst _vertices     = Symbol(\"vertices\");\nconst _edges        = Symbol(\"edges\");\nconst _reverseEdges = Symbol(\"reverse edges\");\nconst _sources      = Symbol(\"sources\");\nconst _sinks        = Symbol(\"sinks\");\nconst _edgeCount    = Symbol(\"edge count\");\n\nconst _listeners = Symbol(\"listeners\");\nconst _trigger   = Symbol(\"trigger\");\n\nconst _verticesFrom         = Symbol(\"vertices from\");\nconst _verticesTo           = Symbol(\"vertices to\");\nconst _verticesWithPathTo   = Symbol(\"vertices with path to\");\nconst _verticesWithPathFrom = Symbol(\"vertices with path from\");\nconst _paths                = Symbol(\"paths\");\n\nconst _expectVertices         = Symbol(\"expect vertices\");\nconst _expectVerticesAbsent   = Symbol(\"expect vertex absent\");\nconst _expectEdges            = Symbol(\"expect edge\");\nconst _expectEdgesAbsent      = Symbol(\"expect edge absent\");\nconst _expectNoConnectedEdges = Symbol(\"expect no connected edges\");\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Graph class /////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @class Graph\n * @classdesc The main class of this library, to be used for representing a mathematical (di)graph.\n *\n * @description Constructor arguments can be used to supply initial vertices and edges.\n * @param ...parts {Array.<Array>}\n *        a short notation for vertices and edges to initially add to the graph;\n *        A vertex should be an array of the form `[key, value]`.\n *        An edge should be an array of the form `[[from, to], value]`.\n *        Later values of vertices or edges in this list will overwrite earlier\n *        values, but vertices need not precede their edges. Vertices that are\n *        connected but store no value need not be listed at all.\n * @example\n * var map = new Graph(\n *     ['Amsterdam',             { population: 825000 }], // vertex\n *     ['Leiden',                { population: 122000 }], // vertex\n *     [['Amsterdam', 'Leiden'], { distance:   \"40km\" }]  // edge\n * );\n */\nclass Graph {\n\n\tconstructor(...parts) {\n\t\t/* storage */\n\t\tthis[_vertices]     = new Map(); // Map.< string, * >\n\t\tthis[_edges]        = new Map(); // Map.< string, Map.<string, *> >\n\n\t\t/* bookkeeping */\n\t\tthis[_reverseEdges] = new Map(); // Map.< string, Set.<*> >\n\t\tthis[_sources]      = new Set(); // Set.< string >\n\t\tthis[_sinks]        = new Set(); // Set.< string >\n\t\tthis[_edgeCount]    = 0;\n\n\t\t/* listeners */\n\t\tthis[_listeners] = new Map();\n\n\t\t/* add vertices and values from constructor arguments */\n\t\tfor (let [key, value] of parts) {\n\t\t\tif (Array.isArray(key)) {/////////////// an edge\n\t\t\t\tlet [from, to] = key;\n\t\t\t\tthis.createEdge(from, to, value);\n\t\t\t} else {//////////////////////////////// a vertex\n\t\t\t\tthis.addVertex(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/////////////////////////////////////\n\t////////// Event Handling //////////\n\t/////////////////////////////////////\n\n\t/**\n\t * Register an event handler.\n\t * @param event   {string}   the event to listen for\n\t * @param handler {Function} the function to call for each such event fired, receiving its corresponding value\n\t */\n\ton(event, handler) {\n\t\tif (!this[_listeners].has(event)) {\n\t\t\tthis[_listeners].set(event, new Set());\n\t\t}\n\t\tthis[_listeners].get(event).add(handler);\n\t}\n\n\t/**\n\t * Deregister a previously registered event handler.\n\t * @param event   {string}   the event used to originally register a handler\n\t * @param handler {Function} the handler originally registered\n\t */\n\toff(event, handler) {\n\t\tif (this[_listeners].has(event)) {\n\t\t\tthis[_listeners].get(event).delete(handler);\n\t\t}\n\t}\n\n\t[_trigger](event, value) {\n\t\tfor (let handler of this[_listeners].get(event) || []) {\n\t\t\thandler(value);\n\t\t}\n\t}\n\n\t/**\n\t * An event that is triggered just after a vertex is added to this graph.\n\t * Handlers receive the new vertex `[key, value]` as an argument.\n\t * @event vertex-added\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered just after a vertex is removed from this graph.\n\t * Handlers receive the vertex key as an argument.\n\t * @event vertex-removed\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered after a vertex in this graph is modified.\n\t * It is also triggered after any {@link #Graph#event_vertex-added|\"vertex-added\"} event.\n\t * Handlers receive the vertex `[key, value]` as an argument.\n\t * @event vertex-modified\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered just after an edge is added to this graph.\n\t * Handlers receive the new edge `[[from, to], value]` as an argument.\n\t * @event edge-added\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered just after an edge is removed from this graph.\n\t * Handlers receive the edge key `[from, to]` as an argument.\n\t * @event edge-removed\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\t/**\n\t * An event that is triggered after an edge in this graph is modified.\n\t * It is also triggered after any {@link #Graph#event_edge-added|\"edge-added\"} event.\n\t * Handlers receive the edge `[[from, to], value]` as an argument.\n\t * @event edge-modified\n\t * @memberof Graph\n\t * @instance\n\t * @see {@link Graph#on}\n\t * @see {@link Graph#off}\n\t */\n\n\n\t//////////////////////////////\n\t////////// Vertices //////////\n\t//////////////////////////////\n\n\t////////// creating them //////////\n\n\t/**\n\t * Add a new vertex to this graph.\n\t * @throws {Graph.VertexExistsError} if a vertex with this key already exists\n\t * @param  key    {string} the key with which to refer to this new vertex\n\t * @param [value] {*}      the value to store in this new vertex\n\t */\n\taddNewVertex(key, value) {\n\t\tthis[_expectVerticesAbsent](key);\n\t\tthis[_vertices].set(key, value);\n\t\tthis[_edges].set(key, new Map());\n\t\tthis[_reverseEdges].set(key, new Set());\n\t\tthis[_sources].add(key);\n\t\tthis[_sinks].add(key);\n\t\tthis[_trigger]('vertex-added',    [key, value]);\n\t\tthis[_trigger]('vertex-modified', [key, value]);\n\t}\n\n\t/**\n\t * Set the value of an existing vertex in this graph.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param  key    {string} the key belonging to the vertex\n\t * @param [value] {*}      the value to store in this vertex\n\t */\n\tsetVertex(key, value) {\n\t\tthis[_expectVertices](key);\n\t\tthis[_vertices].set(key, value);\n\t\tthis[_trigger]('vertex-modified', [key, value]);\n\t}\n\n\t/**\n\t * Make sure a vertex with a specific key exists in this graph. If it already exists,\n\t * do nothing. If it does not yet exist, add a new vertex with the given value.\n\t * @param  key    {string} the key for the vertex\n\t * @param [value] {*}      the value to store if a new vertex is added\n\t */\n\tensureVertex(key, value) {\n\t\tif (!this.hasVertex(key)) {\n\t\t\tthis.addNewVertex(key, value);\n\t\t}\n\t}\n\n\t/**\n\t * Add a new vertex to this graph. If a vertex with this key already exists,\n\t * the value of that vertex is overwritten.\n\t * @param  key    {string} the key with which to refer to this new vertex\n\t * @param [value] {*}      the value to store in this new vertex\n\t */\n\taddVertex(key, value) {\n\t\tif (this.hasVertex(key)) {\n\t\t\tthis.setVertex(key, value);\n\t\t} else {\n\t\t\tthis.addNewVertex(key, value);\n\t\t}\n\t}\n\n\n\t////////// removing them //////////\n\n\t/**\n\t * Remove an existing vertex from this graph.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tremoveExistingVertex(key) {\n\t\tthis[_expectVertices](key);\n\t\tthis[_expectNoConnectedEdges](key);\n\t\tthis[_vertices].delete(key);\n\t\tthis[_sources].delete(key);\n\t\tthis[_sinks].delete(key);\n\t\tthis[_trigger]('vertex-removed', key);\n\t}\n\n\t/**\n\t * Remove an existing vertex from this graph, as well as all edges connected to it.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tdestroyExistingVertex(key) {\n\t\tthis[_expectVertices](key);\n\t\tfor (let [to] of this.verticesFrom(key)) { this.removeEdge(key,  to ) }\n\t\tfor (let [from] of this.verticesTo(key)) { this.removeEdge(from, key) }\n\t\tthis.removeExistingVertex(key);\n\t}\n\n\t/**\n\t * Remove an existing vertex from this graph.\n\t * If a vertex with this key does not exist, nothing happens.\n\t * @throws {Graph.HasConnectedEdgesError} if there are still edges connected to this vertex\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tremoveVertex(key) {\n\t\tif (this.hasVertex(key)) {\n\t\t\tthis.removeExistingVertex(key);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a vertex from this graph, as well as all edges connected to it.\n\t * If a vertex with this key does not exist, nothing happens.\n\t * @param key {string} the key of the vertex to remove\n\t */\n\tdestroyVertex(key) {\n\t\tif (this.hasVertex(key)) {\n\t\t\tthis.destroyExistingVertex(key);\n\t\t}\n\t}\n\n\n\t////////// querying them //////////\n\n\t/**\n\t * @returns {number} the number of vertices in the whole graph\n\t */\n\tvertexCount() { return this[_vertices].size }\n\n\t/**\n\t * Ask whether a vertex with a given key exists.\n\t * @param key {string} the key to query\n\t * @returns {boolean} whether there is a vertex with the given key\n\t */\n\thasVertex(key) { return this[_vertices].has(key) }\n\n\t/**\n\t * Get the value associated with the vertex of a given key.\n\t * @param key {string} the key to query\n\t * @returns {*} the value associated with the vertex of the given key.\n\t * Note that a return value of `undefined` can mean\n\t *\n\t * 1. that there is no such vertex, or\n\t * 2. that the stored value is actually `undefined`.\n\t *\n\t * Use {@link Graph#hasVertex} to distinguish these cases.\n\t */\n\tvertexValue(key) { return this[_vertices].get(key) }\n\n\n\t///////////////////////////\n\t////////// Edges //////////\n\t///////////////////////////\n\n\t////////// adding them //////////\n\n\t/**\n\t * Add a new edge to this graph.\n\t * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this new edge\n\t */\n\taddNewEdge(from, to, value) {\n\t\tthis[_expectEdgesAbsent]([from, to]);\n\t\tthis[_expectVertices](from, to);\n\t\tthis[_edges].get(from).set(to, value);\n\t\tthis[_reverseEdges].get(to).add(from);\n\t\tthis[_edgeCount] += 1;\n\t\tthis[_sources].delete(to);\n\t\tthis[_sinks].delete(from);\n\t\tthis[_trigger]('edge-added',    [[from, to], value]);\n\t\tthis[_trigger]('edge-modified', [[from, to], value]);\n\t}\n\n\t/**\n\t * Add a new edge to this graph. If the `from` and/or `to` vertices do not yet exist\n\t * in the graph, they are implicitly added with an `undefined` value.\n\t * @throws {Graph.EdgeExistsError} if an edge between `from` and `to` already exists\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this new edge\n\t */\n\tcreateNewEdge(from, to, value) {\n\t\tthis[_expectEdgesAbsent]([from, to]);\n\t\tthis.ensureVertex(from);\n\t\tthis.ensureVertex(to);\n\t\tthis.addNewEdge(from, to, value);\n\t}\n\n\t/**\n\t * Set the value of an existing edge in this graph.\n\t * @throws {Graph.EdgeNotExistsError} if an edge between `from` and `to` does not yet exist\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this edge\n\t */\n\tsetEdge(from, to, value) {\n\t\tthis[_expectEdges]([from, to]);\n\t\tthis[_edges].get(from).set(to, value);\n\t\tthis[_trigger]('edge-modified', [[from, to], value]);\n\t}\n\n\t/**\n\t * Make sure an edge between the `from` and `to` vertices in this graph.\n\t * If one already exists, nothing is done.\n\t * If one does not yet exist, a new edge is added with the given value.\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store if a new edge is added\n\t */\n\tspanEdge(from, to, value) {\n\t\tthis[_expectVertices](from, to);\n\t\tif (!this.hasEdge(from, to)) {\n\t\t\tthis.addNewEdge(from, to, value);\n\t\t}\n\t}\n\n\t/**\n\t * Add a new edge to this graph. If an edge between `from` and `to` already exists,\n\t * the value of that edge is overwritten.\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store in this new edge\n\t */\n\taddEdge(from, to, value) {\n\t\tif (this.hasEdge(from, to)) {\n\t\t\tthis.setEdge(from, to, value);\n\t\t} else {\n\t\t\tthis.addNewEdge(from, to, value);\n\t\t}\n\t}\n\n\t/**\n\t * Make sure an edge between the `from` and `to` vertices exists in this graph.\n\t * If it already exists, nothing is done.\n\t * If it does not yet exist, a new edge is added with the given value.\n\t * If the `from` and/or `to` vertices do not yet exist\n\t * in the graph, they are implicitly added with an `undefined` value.\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store if a new edge is added\n\t */\n\tensureEdge(from, to, value) {\n\t\tif (!this.hasEdge(from, to)) {\n\t\t\tthis.createNewEdge(from, to, value);\n\t\t}\n\t}\n\n\t/**\n\t * Add a new edge to this graph. If an edge between the `from` and `to`\n\t * vertices already exists, the value of that edge is overwritten.\n\t * If the `from` and/or `to` vertices do not yet exist\n\t * in the graph, they are implicitly added with an `undefined` value.\n\t * @param  from   {string} the key for the originating vertex\n\t * @param  to     {string} the key for the terminating vertex\n\t * @param [value] {*}      the value to store if a new edge is added\n\t */\n\tcreateEdge(from, to, value) {\n\t\tif (this.hasEdge(from, to)) {\n\t\t\tthis.setEdge(from, to, value);\n\t\t} else {\n\t\t\tthis.createNewEdge(from, to, value);\n\t\t}\n\t}\n\n\n\t////////// removing them //////////\n\n\t/**\n\t * Remove an existing edge from this graph.\n\t * @throws {Graph.EdgeNotExistsError} if an edge between the `from` and `to` vertices doesn't exist\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t */\n\tremoveExistingEdge(from, to) {\n\t\tthis[_expectEdges]([from, to]);\n\t\tthis[_edges].get(from).delete(to);\n\t\tthis[_reverseEdges].get(to).delete(from);\n\t\tthis[_edgeCount] -= 1;\n\t\tif (this. inDegree(to)   === 0) { this[_sources].add(to) }\n\t\tif (this.outDegree(from) === 0) { this[_sinks].add(from) }\n\t\tthis[_trigger]('edge-removed', [from, to]);\n\t}\n\n\t/**\n\t * Remove an edge from this graph.\n\t * If an edge between the `from` and `to` vertices doesn't exist, nothing happens.\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t */\n\tremoveEdge(from, to) {\n\t\tif (this.hasEdge(from, to)) {\n\t\t\tthis.removeExistingEdge(from, to);\n\t\t}\n\t}\n\n\n\t////////// querying them //////////\n\n\t/**\n\t * @returns {number} the number of edges in the whole graph\n\t */\n\tedgeCount() { return this[_edgeCount] }\n\n\t/**\n\t * Ask whether an edge between given `from` and `to` vertices exist.\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t * @returns {boolean} whether there is an edge between the given `from` and `to` vertices\n\t */\n\thasEdge(from, to) {\n\t\treturn this.hasVertex(from) &&\n\t\t\tthis.hasVertex(to) &&\n\t\t\tthis[_edges].has(from) &&\n\t\t\tthis[_edges].get(from).has(to);\n\t}\n\n\t/**\n\t * Get the value associated with the edge between given `from` and `to` vertices.\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t * @returns {*} the value associated with the edge between the given `from` and `to` vertices\n\t * Note that a return value of `undefined` can mean\n\t *\n\t * 1. that there is no such edge, or\n\t * 2. that the stored value is actually `undefined`.\n\t *\n\t * Use {@link Graph#hasEdge} to distinguish these cases.\n\t */\n\tedgeValue(from, to) {\n\t\treturn this.hasEdge(from, to) ? this[_edges].get(from).get(to) : undefined;\n\t}\n\n\n\t///////////////////////////////////////////////\n\t//////////// ES6 Iterable interfaces //////////\n\t///////////////////////////////////////////////\n\n\t/**\n\t * Iterate over all vertices of the graph, in no particular order.\n\t * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.vertices(), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices of the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.vertices()) {\n\t *     // iterates over all vertices of the graph\n\t * }\n\t * @see {@link Graph#@@iterator}\n\t */\n\t*vertices() {\n\t\tlet done = new Set();\n\t\tfor (let [key, value] of this[_vertices]) {\n\t\t\tif (this.hasVertex(key) && !done.has(key)) {\n\t\t\t\tdone.add(key);\n\t\t\t\tyield [key, value];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A {@link Graph} object is itself {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol|iterable},\n\t * and serves as a short notation in ECMAScript 6 to iterate over all vertices in the graph, in no particular order.\n\t * @method Graph#@@iterator\n\t * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (let [key, value] of graph) {\n\t *     // iterates over all vertices of the graph\n\t * }\n\t * @see {@link Graph#vertices}\n\t */\n\t[Symbol.iterator]() { return this.vertices() }\n\n\t/**\n\t * Iterate over all edges of the graph, in no particular order.\n\t * @returns { Iterator.<string, string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.edges(), kv; !(kv = it.next()).done;) {\n\t *     var from  = kv.value[0],\n\t *         to    = kv.value[1],\n\t *         value = kv.value[2];\n\t *     // iterates over all edges of the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [from, to, value] of graph.edges()) {\n\t *     // iterates over all vertices of the graph\n\t * }\n\t */\n\t*edges() {\n\t\tlet done = new Map();\n\t\tfor (let from of this[_edges].keys()) {\n\t\t\tdone.set(from, new Set());\n\t\t\tfor (let to of this[_edges].get(from).keys()) {\n\t\t\t\tif (this.hasEdge(from, to) && !done.get(from).has(to)) {\n\t\t\t\t\tdone.get(from).add(to);\n\t\t\t\t\tyield [from, to, this[_edges].get(from).get(to)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over the outgoing edges of a given vertex in the graph, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist\n\t * @param from {string} the key of the vertex to take the outgoing edges from\n\t * @returns { Iterator.<string, *, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.verticesFrom(from), kv; !(kv = it.next()).done;) {\n\t *     var to          = kv.value[0],\n\t *         vertexValue = kv.value[1],\n\t *         edgeValue   = kv.value[2];\n\t *     // iterates over all outgoing vertices of the `from` vertex\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [to, vertexValue, edgeValue] of graph.verticesFrom(from)) {\n\t *     // iterates over all outgoing edges of the `from` vertex\n\t * }\n\t */\n\tverticesFrom(from) {\n\t\tthis[_expectVertices](from);\n\t\treturn this[_verticesFrom](from);\n\t}\n\t*[_verticesFrom](from) {\n\t\tlet done = new Set();\n\t\tfor (let to of this[_edges].get(from).keys()) {\n\t\t\tif (this.hasEdge(from, to) && !done.has(to)) {\n\t\t\t\tdone.add(to);\n\t\t\t\tyield [to, this[_vertices].get(to), this[_edges].get(from).get(to)];\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Iterate over the incoming edges of a given vertex in the graph, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist\n\t * @param to {string} the key of the vertex to take the incoming edges from\n\t * @returns { Iterator.<string, *, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.verticesTo(to), kv; !(kv = it.next()).done;) {\n\t *     var from        = kv.value[0],\n\t *         vertexValue = kv.value[1],\n\t *         edgeValue   = kv.value[2];\n\t *     // iterates over all outgoing vertices of the `from` vertex\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [from, vertexValue, edgeValue] of graph.verticesTo(to)) {\n\t *     // iterates over all incoming edges of the `to` vertex\n\t * }\n\t */\n\tverticesTo(to) {\n\t\tthis[_expectVertices](to);\n\t\treturn this[_verticesTo](to);\n\t}\n\t*[_verticesTo](to) {\n\t\tlet done = new Set();\n\t\tfor (let from of this[_reverseEdges].get(to)) {\n\t\t\tif (this.hasEdge(from, to) && !done.has(from)) {\n\t\t\t\tdone.add(from);\n\t\t\t\tyield [from, this[_vertices].get(from), this[_edges].get(from).get(to)];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over all vertices reachable from a given vertex in the graph, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `from` key does not exist\n\t * @param from {string} the key of the vertex to take the reachable vertices from\n\t * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.verticesWithPathFrom(from), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices reachable from `from`\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.verticesWithPathFrom(from)) {\n\t *     // iterates over all vertices reachable from `from`\n\t * }\n\t */\n\tverticesWithPathFrom(from) {\n\t\tthis[_expectVertices](from);\n\t\treturn this[_verticesWithPathFrom](from, new Set());\n\t}\n\t*[_verticesWithPathFrom](from, done) {\n\t\tfor (let to of this[_edges].get(from).keys()) {\n\t\t\tif (this.hasEdge(from, to) && !done.has(to)) {\n\t\t\t\tdone.add(to);\n\t\t\t\tyield [to, this[_vertices].get(to)];\n\t\t\t\tyield* this[_verticesWithPathFrom](to, done);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterate over all vertices from which a given vertex in the graph can be reached, in no particular order.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with the given `to` key does not exist\n\t * @param to {string} the key of the vertex to take the reachable vertices from\n\t * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.verticesWithPathTo(to), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices from which `to` can be reached\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.verticesWithPathTo(to)) {\n\t *     // iterates over all vertices from which `to` can be reached\n\t * }\n\t */\n\tverticesWithPathTo(to) {\n\t\tthis[_expectVertices](to);\n\t\treturn this[_verticesWithPathTo](to, new Set());\n\t}\n\t*[_verticesWithPathTo](to, done) {\n\t\tfor (let from of this[_reverseEdges].get(to)) {\n\t\t\tif (this.hasEdge(from, to) && !done.has(from)) {\n\t\t\t\tdone.add(from);\n\t\t\t\tyield [from, this[_vertices].get(from)];\n\t\t\t\tyield* this[_verticesWithPathTo](from, done);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Iterate over all vertices that have no incoming edges, in no particular order.\n\t * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.sources(), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices with no incoming edges\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.sources()) {\n\t *     // iterates over all vertices with no incoming edges\n\t * }\n\t */\n\t*sources() {\n\t\tlet done = new Set();\n\t\tfor (let key of this[_sources]) {\n\t\t\tif (this.hasVertex(key) && !done.has(key)) {\n\t\t\t\tdone.add(key);\n\t\t\t\tyield [key, this.vertexValue(key)];\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Iterate over all vertices that have no outgoing edges, in no particular order.\n\t * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.sinks(), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices with no outgoing edges\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.sinks()) {\n\t *     // iterates over all vertices with no outgoing edges\n\t * }\n\t */\n\t*sinks() {\n\t\tlet done = new Set();\n\t\tfor (let key of this[_sinks]) {\n\t\t\tif (this.hasVertex(key) && !done.has(key)) {\n\t\t\t\tdone.add(key);\n\t\t\t\tyield [key, this.vertexValue(key)];\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Iterate over all vertices of the graph in topological order.\n\t * @returns { Iterator.<string, *> } an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}\n\t * @example\n\t * for (var it = graph.vertices_topologically(), kv; !(kv = it.next()).done;) {\n\t *     var key   = kv.value[0],\n\t *         value = kv.value[1];\n\t *     // iterates over all vertices of the graph in topological order\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let [key, value] of graph.vertices_topologically()) {\n\t *     // iterates over all vertices of the graph in topological order\n\t * }\n\t */\n\t*vertices_topologically() {\n\t\tlet visited = []; // stack\n\t\tlet handled = new Set();\n\n\t\tlet _this = this;\n\t\tfunction *visit(a) {\n\t\t\tvisited.push(a);\n\t\t\tlet i = visited.indexOf(a);\n\t\t\tif (i !== visited.length - 1) {\n\t\t\t\tlet cycle = visited.slice(i + 1).reverse();\n\t\t\t\tthrow new Graph.CycleError(cycle);\n\t\t\t}\n\t\t\tif (!handled.has(a)) {\n\t\t\t\tfor (let [b] of _this.verticesTo(a)) {\n\t\t\t\t\tyield* visit(b);\n\t\t\t\t}\n\t\t\t\tif (_this.hasVertex(a)) {\n\t\t\t\t\tyield [a, _this[_vertices].get(a)];\n\t\t\t\t}\n\t\t\t\thandled.add(a);\n\t\t\t}\n\t\t\tvisited.pop();\n\t\t}\n\t\tfor (let [a] of this.vertices()) {\n\t\t\tif (!handled.has(a)) {\n\t\t\t\tyield* visit(a);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t//////////////////////////////\n\t////////// Clearing //////////\n\t//////////////////////////////\n\n\t/**\n\t * Remove all edges from the graph, but leave the vertices intact.\n\t */\n\tclearEdges() {\n\t\tfor (let [from, to] of this.edges()) { this.removeEdge(from, to) }\n\t}\n\n\t/**\n\t * Remove all edges and vertices from the graph, putting it back in its initial state.\n\t */\n\tclear() {\n\t\tfor (let [v] of this.vertices()) { this.destroyVertex(v) }\n\t}\n\n\n\t////////////////////////////////////////\n\t////////// (Advanced) Queries //////////\n\t////////////////////////////////////////\n\n\n\t/**\n\t * Ask whether `this` graph and a given `other` graph are equal.\n\t * Two graphs are equal if they have the same vertices and the same edges.\n\t * @param other {Graph} the other graph to compare to `this` one\n\t * @param [eqV] {function(*, *, string): boolean}\n\t *     a custom equality function for values stored in vertices;\n\t *     defaults to `===` comparison; The first two arguments are the\n\t *     values to compare. The third is the corresponding `key`.\n\t * @param [eqE] {function(*, *, string, string): boolean}\n\t *     a custom equality function for values stored in edges;\n\t *     defaults to the function given for `trV`; The first two arguments\n\t *     are the values to compare. The third and fourth are the `from`\n\t *     and `to` keys respectively.\n\t * @returns {boolean} `true` if the two graphs are equal; `false` otherwise\n\t */\n\tequals(other, eqV=(x,y)=>(x===y), eqE=eqV) {\n\t\tif (!(other instanceof Graph))                  { return false }\n\t\tif (this.vertexCount() !== other.vertexCount()) { return false }\n\t\tif (this.edgeCount()   !== other.edgeCount()  ) { return false }\n\t\tfor (let [key, value] of this.vertices()) {\n\t\t\tif (!other.hasVertex(key))                    { return false }\n\t\t\tif (!eqV(value, other.vertexValue(key), key)) { return false }\n\t\t}\n\t\tfor (let [from, to, value] of this.edges()) {\n\t\t\tif (!other.hasEdge(from, to))                         { return false }\n\t\t\tif (!eqE(value, other.edgeValue(from, to), from, to)) { return false }\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Iterate over all simple directed cycles in this graph, in no particular order.\n\t * If you mutate the graph in between iterations, behavior of the iterator\n\t * becomes unspecified. (So, don't.)\n\t * @returns { Iterator.< Array.<string> > }\n\t *          an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}.\n\t *          Each iterated value is an array containing the vertex keys describing the cycle.\n\t *          These arrays will contain each vertex key only once — even the first/last one.\n\t * @example\n\t * for (var it = graph.cycles(), kv; !(kv = it.next()).done;) {\n\t *     var cycle = kv.value;\n\t *     // iterates over all cycles of the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let cycle of graph.cycles()) {\n\t *     // iterates over all cycles of the graph\n\t * }\n\t */\n\t*cycles() {\n\t\t// This algorithm is based on the following article:\n\t\t// Enumeration of the elementary circuits of a directed graph\n\t\t// R. Tarjan, SIAM Journal on Computing, 2 (1973), pp. 211-216\n\t\t// http://dx.doi.org/10.1137/0202017\n\t\t// -----\n\t\t// TODO: implement the improved version as defined by Johnson:\n\t\t// Finding all the elementary circuits of a directed graph.\n\t\t// D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.\n\t\t// http://dx.doi.org/10.1137/0204007\n\n\t\t/* bookkeeping */\n\t\tlet pointStack = [];\n\t\tlet markedStack, mark;\n\n\t\t/* the main recursive backtracking algorithm */\n\t\tlet _this = this;\n\t\tfunction* backtrack(v, out = {}) {\n\t\t\tpointStack.push(v);\n\t\t\tmark.add(v);\n\t\t\tmarkedStack.push(v);\n\t\t\tfor (let [w] of [..._this.verticesFrom(v)]) {\n\t\t\t\tif (w < pointStack[0]) { continue }\n\t\t\t\tif (w === pointStack[0]) {\n\t\t\t\t\tyield [...pointStack];\n\t\t\t\t\tout.found = true;\n\t\t\t\t} else if (!mark.has(w)) {\n\t\t\t\t\tlet o = {};\n\t\t\t\t\tyield* backtrack(w, o);\n\t\t\t\t\tout.found = out.found || o.found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (out.found) { // if a simple cycle continuing the partial path on the pointStack has been found\n\t\t\t\tlet u;\n\t\t\t\tdo {\n\t\t\t\t\tu = markedStack.pop();\n\t\t\t\t\tmark.delete(u);\n\t\t\t\t} while (u !== v);\n\t\t\t}\n\t\t\tpointStack.pop();\n\t\t}\n\n\t\t/* start backtracking from each vertex in the graph */\n\t\tfor (let [a] of this.vertices()) {\n\t\t\tmarkedStack = [];\n\t\t\tmark = new Set();\n\t\t\tyield* backtrack(a);\n\t\t}\n\t}\n\n\n\t/**\n\t * Find any directed cycle in this graph.\n\t * @returns {?Array} an array containing the vertex keys describing the cycle; `null`, if there is no cycle;\n\t *                   The array will contain each vertex key only once — even the first/last one.\n\t */\n\tcycle() {\n\t\tlet result = this.cycles().next();\n\t\treturn result.done ? null : result.value;\n\t}\n\n\n\t/**\n\t * Test whether this graph contains a directed cycle.\n\t * @returns {boolean} whether this graph contains any directed cycle\n\t */\n\thasCycle() { return !this.cycles().next().done }\n\n\n\t/**\n\t * Iterate over all paths between two given keys in this graph, in no particular order.\n\t * If you mutate the graph in between iterations, behavior of the iterator\n\t * becomes unspecified. (So, don't.)\n\t * @param from {string} the key for the originating vertex\n\t * @param to   {string} the key for the terminating vertex\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @returns { Iterator.< Array.<string> > }\n\t *          an object conforming to the {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol|ES6 iterator protocol}.\n\t *          Each iterated value is an array containing the vertex-keys describing the path.\n\t * @example\n\t * for (var it = graph.paths(), kv; !(kv = it.next()).done;) {\n\t *     var path = kv.value;\n\t *     // iterates over all paths between `from` and `to` in the graph\n\t * }\n\t * @example\n\t * // in ECMAScript 6, you can use a for..of loop\n\t * for (let path of graph.paths()) {\n\t *     // iterates over all paths between `from` and `to` in the graph\n\t * }\n\t */\n\tpaths(from, to) {\n\t\tthis[_expectVertices](from, to);\n\t\treturn this[_paths](from, to);\n\t}\n\t*[_paths](from, to) {\n\t\tlet stack = [];\n\n\t\tlet _this = this;\n\t\tfunction *pathsFromPrefix(current) {\n\t\t\tstack.push(current);\n\t\t\tfor (let [next] of _this.verticesFrom(current)) {\n\t\t\t\tif (next === to) {\n\t\t\t\t\tyield [...stack, to];\n\t\t\t\t} else if (stack.indexOf(next) === -1) {\n\t\t\t\t\tyield* pathsFromPrefix(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\n\t\tyield* pathsFromPrefix(from);\n\t}\n\n\n\t/**\n\t * Find any path between a given pair of keys.\n\t * @param from {string} the originating vertex\n\t * @param to   {string} the terminating vertex\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @returns {?Array} an array with the keys of the path found between the two vertices,\n\t *                   including those two vertices themselves; `null` if no such path exists\n\t */\n\tpath(from, to) {\n\t\tlet result = this.paths(from, to).next();\n\t\treturn result.done ? null : result.value;\n\t}\n\n\n\t/**\n\t * Test whether there is a directed path between a given pair of keys.\n\t * @param from {string} the originating vertex\n\t * @param to   {string} the terminating vertex\n\t * @throws {Graph.VertexNotExistsError} if the `from` and/or `to` vertices do not yet exist in the graph\n\t * @returns {boolean} whether such a path exists\n\t */\n\thasPath(from, to) { return !this.paths(from, to).next().done }\n\n\n\t/**\n\t * Get the number of edges going out of a given vertex.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to query\n\t * @returns {number} the number of edges going out of the `key` vertex\n\t */\n\toutDegree(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_edges].get(key).size;\n\t}\n\n\n\t/**\n\t * Get the number of edges coming into a given vertex.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to query\n\t * @returns {number} the number of edges coming into the `key` vertex\n\t */\n\tinDegree(key) {\n\t\tthis[_expectVertices](key);\n\t\treturn this[_reverseEdges].get(key).size;\n\t}\n\n\n\t/**\n\t * Get the number of edges connected to a given vertex.\n\t * @throws {Graph.VertexNotExistsError} if a vertex with this key does not exist\n\t * @param key {string} the key of the vertex to query\n\t * @returns {number} the number of edges connected to the `key` vertex\n\t */\n\tdegree(key) { return this.outDegree(key) + this.inDegree(key) }\n\n\n\t///////////////////////////////////////\n\t////////// Cloning and stuff //////////\n\t///////////////////////////////////////\n\n\n\t/**\n\t * Merge another graph into this graph.\n\t * @param other {Graph} the other graph to merge into this one\n\t * @param [mV] {function(*, *, string): *}\n\t *     a custom merge function for values stored in vertices;\n\t *     defaults to whichever of the two values is not `undefined`,\n\t *     giving preference to that of the other graph; The first and\n\t *     second arguments are the vertex values of `this` graph and the\n\t *     `other` graph respectively. The third is the corresponding `key`.\n\t * @param [mE] {function(*, *, string, string): *}\n\t *     a custom merge function for values stored in edges;\n\t *     defaults to whichever of the two values is not `undefined`,\n\t *     giving preference to that of the other graph; The first and\n\t *     second arguments are the edge values of `this` graph and the\n\t *     `other` graph respectively. The third and fourth are the\n\t *     corresponding `from` and `to` keys.\n\t */\n\tmergeIn(other, mV, mE) {\n\t\tif (!mV) { mV = (v1,v2)=>(typeof v2 === 'undefined' ? v1 : v2) }\n\t\tif (!mE) { mE = mV }\n\t\tfor (let [key] of other.vertices()) {\n\t\t\tthis.addVertex(key, mV(this.vertexValue(key), other.vertexValue(key), key));\n\t\t}\n\t\tfor (let [from, to] of other.edges()) {\n\t\t\tthis.addEdge(from, to, mE(this.edgeValue(from, to), other.edgeValue(from, to), from, to));\n\t\t}\n\t}\n\n\n\t/**\n\t * Create a clone of this graph.\n\t * @param [trV] {function(*, string): *}\n\t *     a custom transformation function for values stored in vertices;\n\t *     defaults to the identity function; The first argument is the\n\t *     value to clone. The second is the corresponding `key`.\n\t * @param [trE] {function(*, string, string): *}\n\t *     a custom transformation function for values stored in edges;\n\t *     defaults to the function given for `trV`; The first argument\n\t *     is the value to clone. The second and third are the `from`\n\t *     and `to` keys respectively.\n\t * @returns {Graph} a clone of this graph\n\t */\n\tclone(trV=(v=>v), trE=trV) {\n\t\tlet result = new Graph();\n\t\tresult.mergeIn(this, (v1, v2, key) => trV(v2, key), (v1, v2, from, to) => trE(v2, from, to));\n\t\treturn result;\n\t}\n\n\n\t/**\n\t * Create a clone of this graph, but without any transitive edges.\n\t * @param [trV] {function(*, string): *}\n\t *     a custom transformation function for values stored in vertices;\n\t *     defaults to the identity function; The first argument is the\n\t *     value to clone. The second is the corresponding `key`.\n\t * @param [trE] {function(*, string, string): *}\n\t *     a custom transformation function for values stored in edges;\n\t *     defaults to the function given for `trV`; The first argument\n\t *     is the value to clone. The second and third are the `from`\n\t *     and `to` keys respectively.\n\t * @returns {Graph} a clone of this graph with all transitive edges removed\n\t */\n\ttransitiveReduction(trV, trE) {\n\t\t// argument defaults are handled in `clone`\n\t\tlet result = this.clone(trV, trE);\n\t\tfor (let [x] of this.vertices())\n\t\t\tfor (let [y] of this.vertices())\n\t\t\t\tif (result.hasEdge(x, y))\n\t\t\t\t\tfor (let [z] of this.vertices())\n\t\t\t\t\t\tif (result.hasPath(y, z))\n\t\t\t\t\t\t\tresult.removeEdge(x, z);\n\t\treturn result;\n\t}\n\n\t/**\n\t * This method replaces stretches of non-branching directed pathway into single edges.\n\t * More specifically, it identifies all 'nexus' vertices in the graph and preserves them.\n\t * It then removes all other vertices and all edges from the graph, then inserts edges\n\t * between nexuses that summarize the connectivity that was there before.\n\t *\n\t * A nexus is any vertex that is *not* characterized by '1 edge in, 1 edge out'.\n\t * A custom `isNexus` function may be provided to manually select additional vertices\n\t * that should be preserved as nexus.\n\t * @param [isNexus] {function(string, *): boolean}\n\t *                  a predicate for identifying additional vertices that should be treated as nexus;\n\t *                  It receives a `key` and `value` associated to a vertex and should return\n\t *                  true if and only if that vertex should be a nexus.\n\t * @throws {Graph.BranchlessCycleError} if the graph contains a cycle with no branches or nexuses\n\t */\n\tcontractPaths(isNexus=(()=>false)) {\n\n\t\t/* what makes a a vertex a nexus (start/end-point) */\n\t\tlet nexuses = new Set(\n\t\t\t[...this.vertices()]\n\t\t\t\t.filter(([key, val]) => this.outDegree(key) !== 1 || this.inDegree(key) !== 1 || isNexus(key, val))\n\t\t\t\t.map(([key]) => key)\n\t\t);\n\n\t\t/* error if there is a branch-less cycle */\n\t\t{\n\t\t\tlet unhandledVertices = new Set([...this.vertices()].map(([key])=>key));\n\t\t\tconst checkForBlCycle = (key) => {\n\t\t\t\tif (!unhandledVertices.has(key)) { return }\n\t\t\t\tunhandledVertices.delete(key);\n\t\t\t\tfor (let [next] of this.verticesFrom(key)) { checkForBlCycle(next) }\n\t\t\t\tfor (let [next] of this.verticesTo  (key)) { checkForBlCycle(next) }\n\t\t\t};\n\t\t\tfor (let key of nexuses) { checkForBlCycle(key) }\n\t\t\tif (unhandledVertices.size > 0) {\n\t\t\t\tlet startingKey = unhandledVertices.values().next().value,\n\t\t\t\t    cycle       = [],\n\t\t\t\t    current     = startingKey;\n\t\t\t\tdo {\n\t\t\t\t\tcycle.push(current);\n\t\t\t\t\tcurrent = this.verticesFrom(current).next().value[0];\n\t\t\t\t} while (current !== startingKey);\n\t\t\t\tthrow new Graph.BranchlessCycleError(cycle);\n\t\t\t}\n\t\t}\n\n\t\t/* bookkeeping */\n\t\tlet contractionsToAdd = new Map();\n\n\t\t/* register the path starting with the given edge */\n\t\tconst startPath = (start, next, backwards) => {\n\t\t\t/* functions to help branch on `backwards` */\n\t\t\tconst fromTo       = (strt = start, nxt = next) => backwards ? [nxt, strt] : [strt, nxt];\n\t\t\tconst verticesNext = (v) => backwards ? this.verticesTo(v) : this.verticesFrom(v);\n\n\t\t\t/* bookkeeping */\n\t\t\tlet verticesToRemove = new Set();\n\t\t\tlet edgesToRemove    = new Set();\n\t\t\tlet path = new Graph();\n\n\t\t\t/* process the start of the path */\n\t\t\tpath.addVertex(start, this.vertexValue(start));\n\t\t\tpath.addVertex(next,  this.vertexValue(next) );\n\t\t\tpath.addNewEdge(...fromTo(), this.edgeValue(...fromTo()));\n\t\t\tedgesToRemove.add(fromTo());\n\n\t\t\t/* process as [current, next] moves across the path */\n\t\t\tlet current;\n\t\t\twhile (!nexuses.has(next)) {\n\t\t\t\t[current, next] = [next, verticesNext(next).next().value[0]];\n\t\t\t\tpath.addVertex(next, this.vertexValue(next));\n\t\t\t\tpath.addNewEdge(...fromTo(current, next), this.edgeValue(...fromTo(current, next)));\n\t\t\t\tverticesToRemove.add(current);\n\t\t\t\tedgesToRemove.add(fromTo(current, next));\n\t\t\t}\n\n\t\t\t/* register new path contraction */\n\t\t\tif (!contractionsToAdd.get(fromTo()[0]))                  { contractionsToAdd.set(fromTo()[0], new Map())                    }\n\t\t\tif (!contractionsToAdd.get(fromTo()[0]).get(fromTo()[1])) { contractionsToAdd.get(fromTo()[0]).set(fromTo()[1], new Graph()) }\n\t\t\tcontractionsToAdd.get(fromTo()[0]).get(fromTo()[1]).mergeIn(path);\n\n\t\t\t/* remove old edges and vertices */\n\t\t\tfor (let key of edgesToRemove)    { this.removeExistingEdge(...key) }\n\t\t\tfor (let key of verticesToRemove) { this.destroyExistingVertex(key) }\n\t\t};\n\n\t\t/* process paths starting at all nexus points */\n\t\tfor (let first of nexuses) {\n\t\t\tfor (let [next] of this.verticesFrom(first)) { startPath(first, next, false) }\n\t\t\tfor (let [next] of this.verticesTo  (first)) { startPath(first, next, true)  }\n\t\t}\n\n\t\t/* add the replacement edges */\n\t\tfor (let [from, toVal] of contractionsToAdd)\n\t\t\tfor (let [to, rememberedPath] of toVal)\n\t\t\t\tthis.addNewEdge(from, to, rememberedPath);\n\t}\n\n\n\t///////////////////////////////////\n\t////////// Serialization //////////\n\t///////////////////////////////////\n\n\t/**\n\t * Serialize this graph into a JSON string.\n\t * The resulting string can be deserialized with `Graph.fromJSON`\n\t * @returns {string} a JSON string representation of the current state of this graph\n\t * @see {@link Graph.fromJSON}\n\t * @example\n\t * let json   = graph1.toJSON();\n\t * let graph2 = Graph.fromJSON(json);\n\t * console.log(graph1.equals(graph2)); // true\n\t */\n\ttoJSON() {\n\t\tlet result = [];\n\t\tfor (let [key, val] of this.vertices()) {\n\t\t\tif (typeof val === 'undefined') {\n\t\t\t\tresult.push([key]);\n\t\t\t} else {\n\t\t\t\tresult.push([key, val]);\n\t\t\t}\n\t\t}\n\t\tfor (let [from, to, val] of this.edges()) {\n\t\t\tif (typeof val === 'undefined') {\n\t\t\t\tresult.push([[from, to]]);\n\t\t\t} else {\n\t\t\t\tresult.push([[from, to], val]);\n\t\t\t}\n\t\t}\n\t\treturn JSON.stringify(result);\n\t}\n\n\t/**\n\t * Deserialize a string returned from `.toJSON()`\n\t * into a new `Graph` instance equal to the original.\n\t * @param json {string} a string originally returned from `.toJSON()`\n\t * @returns {Graph} a graph equal to the original\n\t * @see {@link Graph#toJSON}\n\t * @example\n\t * let json   = graph1.toJSON();\n\t * let graph2 = Graph.fromJSON(json);\n\t * console.log(graph1.equals(graph2)); // true\n\t */\n\tstatic fromJSON(json) {\n\t\treturn new this(...JSON.parse(json));\n\t}\n\n\n\t////////////////////////////////\n\t////////// Assertions //////////\n\t////////////////////////////////\n\n\t[_expectVertices](...keys) {\n\t\tlet missingVertices = keys.filter(k => !this.hasVertex(k));\n\t\tif (missingVertices.length) { throw new Graph.VertexNotExistsError(...missingVertices) }\n\t}\n\n\t[_expectVerticesAbsent](...keys) {\n\t\tlet presentVertices = keys.filter(k => this.hasVertex(k));\n\t\tif (presentVertices.length) {\n\t\t\tthrow new Graph.VertexExistsError(...presentVertices.map(k => [k, this.vertexValue(k)]));\n\t\t}\n\t}\n\n\t[_expectEdges](...keys) {\n\t\tlet absentEdges = keys.filter(k => !this.hasEdge(...k));\n\t\tif (absentEdges.length) {\n\t\t\tthrow new Graph.EdgeNotExistsError(...absentEdges);\n\t\t}\n\t}\n\n\t[_expectEdgesAbsent](...keys) {\n\t\tlet presentEdges = keys.filter(k => this.hasEdge(...k));\n\t\tif (presentEdges.length) {\n\t\t\tthrow new Graph.EdgeExistsError(...presentEdges.map(k => [k, this.edgeValue(...k)]));\n\t\t}\n\t}\n\n\t[_expectNoConnectedEdges](key) {\n\t\tlet edges = [];\n\t\tfor (let [to]   of this.verticesFrom(key)) { edges.push([[key,  to ], this.edgeValue(key,  to )]) }\n\t\tfor (let [from] of this.verticesTo  (key)) { edges.push([[from, key], this.edgeValue(from, key)]) }\n\t\tif (edges.length) { throw new Graph.HasConnectedEdgesError(key, ...edges) }\n\t}\n\n}\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Errors //////////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific vertices are expected not to exist, but do.\n * @extends Error\n */\nGraph.VertexExistsError = class VertexExistsError extends Error {\n\tconstructor(...vertices) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant vertices as `[key, value]` shaped arrays\n\t\t * @public\n\t\t * @constant vertices\n\t\t * @memberof Graph.VertexExistsError\n\t\t * @instance\n\t\t * @type {Set.<Array>}\n\t\t */\n\t\tthis.vertices = new Set(vertices);\n\t\tthis.message = `This graph has ${\n\t\t\tthis.vertices.size === 1 ? \"a vertex\" : \"vertices\"\n\t\t} '${\n\t\t\t[...this.vertices].map(([key]) => key).join(`', '`)\n\t\t}'`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific vertices are expected to exist, but don't.\n * @extends Error\n */\nGraph.VertexNotExistsError = class VertexNotExistsError extends Error {\n\tconstructor(...keys) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant vertex keys\n\t\t * @public\n\t\t * @constant vertices\n\t\t * @memberof Graph.VertexNotExistsError\n\t\t * @instance\n\t\t * @type {Set.<string>}\n\t\t */\n\t\tthis.vertices = new Set(keys);\n\t\tthis.message = `This graph does not have ${\n\t\t\tthis.vertices.size === 1 ? \"a vertex\" : \"vertices\"\n\t\t} '${\n\t\t\t[...this.vertices].join(`', '`)\n\t\t}'`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific edges are expected not to exist, but do.\n * @extends Error\n */\nGraph.EdgeExistsError = class EdgeExistsError extends Error {\n\tconstructor(...edges) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant edges as `[[from, to], value]` shaped arrays\n\t\t * @public\n\t\t * @constant edges\n\t\t * @memberof Graph.EdgeExistsError\n\t\t * @instance\n\t\t * @type {Set.<Array>}\n\t\t */\n\t\tthis.edges = new Set(edges);\n\t\tthis.message = `This graph has ${\n\t\t\tthis.edges.size === 1 ? \"an edge\" : \"edges\"\n\t\t} ${\n\t\t\t[...this.edges].map(([[from, to]]) => `['${from}', '${to}']`).join(`, `)\n\t\t}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when specific edges are expected to exist, but don't.\n * @extends Error\n */\nGraph.EdgeNotExistsError = class EdgeNotExistsError extends Error {\n\tconstructor(...edges) {\n\t\tsuper();\n\t\t/**\n\t\t * the set of relevant edge keys as `[from, to]` shaped arrays\n\t\t * @public\n\t\t * @constant edges\n\t\t * @memberof Graph.EdgeNotExistsError\n\t\t * @instance\n\t\t * @type {Set.<Array.<string>>}\n\t\t */\n\t\tthis.edges = new Set(edges);\n\t\tthis.message = `This graph does not have ${\n\t\t\tthis.edges.size === 1 ? \"an edge\" : \"edges\"\n\t\t} ${\n\t\t\t[...this.edges].map(([from, to]) => `['${from}', '${to}']`).join(`, `)\n\t\t}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when a vertex is expected not to have any connected edges, but does.\n * @extends Graph.EdgeExistsError\n */\nGraph.HasConnectedEdgesError = class HasConnectedEdgesError extends Graph.EdgeExistsError {\n\tconstructor(key, ...edges) {\n\t\tsuper(...edges);\n\t\t/**\n\t\t * the key of the vertex that has connected edges\n\t\t * @public\n\t\t * @constant vertex\n\t\t * @memberof Graph.HasConnectedEdgesError\n\t\t * @instance\n\t\t * @type {string}\n\t\t */\n\t\tthis.vertex = key;\n\t\tthis.message = `The '${key}' vertex has connected ${\n\t\t\tthis.edges.size === 1 ? \"an edge\" : \"edges\"\n\t\t} ${\n\t\t\t[...this.edges].map(([[from, to]]) => `['${from}', '${to}']`).join(`, `)\n\t\t}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when a graph is expected not to have a directed cycle, but does.\n * @extends Error\n */\nGraph.CycleError = class CycleError extends Error {\n\tconstructor(cycle) {\n\t\tsuper();\n\t\t/**\n\t\t * the vertices involved in the cycle, in order but with an unspecified starting point\n\t\t * @public\n\t\t * @constant cycle\n\t\t * @memberof Graph.CycleError\n\t\t * @instance\n\t\t * @type {Array.<string>}\n\t\t */\n\t\tthis.cycle = cycle;\n\t\tthis.message = `This graph contains a cycle: ${cycle}`;\n\t}\n};\n\n/**\n * @class\n * @classdesc This type of error is thrown when a graph is expected not to have a branch-less directed cycle, but does.\n * @extends Graph.CycleError\n */\nGraph.BranchlessCycleError = class BranchlessCycleError extends Graph.CycleError {\n\tconstructor(cycle) {\n\t\tsuper(cycle);\n\t\tthis.message = `This graph contains a branch-less cycle: ${cycle}`;\n\t}\n};\n\nmodule.exports = Graph;\n\n\n\n// WEBPACK FOOTER //\n// ./src/graph.es6.js"]}